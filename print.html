<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>argparse-cpp Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Argument Parser in C++ inspired by python&#x27;s argparse module">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user_guide/installation.html">Installation</a></li><li class="chapter-item expanded "><a href="user_guide/running_tests.html">Running the Unit Tests</a></li><li class="chapter-item expanded "><a href="user_guide/basic_example.html">Basic Example</a></li><li class="chapter-item expanded affix "><li class="part-title">In-Depth Docs</li><li class="chapter-item expanded "><a href="in_depth/argument_parser_objects.html">ArgumentParser objects</a></li><li class="chapter-item expanded "><a href="in_depth/add_argument.html">The add_argument() method</a></li><li class="chapter-item expanded "><a href="in_depth/parse_args.html">The parse_args() method</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_type.html">set_type()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_flags.html">set_flags()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_help.html">set_help()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_default.html">set_default()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_metavar.html">set_metavar()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/set_nargs.html">set_nargs()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/count.html">count()</a></li><li class="chapter-item expanded "><a href="in_depth/arg_methods/as.html">as()</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">argparse-cpp Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dead-tech/argparse-cpp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>arparse-cpp</strong> is a single header only library for parsing command line arguments in C++. It is also ideal for creating various CLI tools thanks to its clean and comprehensible API.</p>
<ul>
<li>Available on <a href="https://github.com/conan-io/conan">Conan</a></li>
<li>Written in C++20</li>
<li>Unit tested with <a href="https://github.com/catchorg/Catch2">Catch2</a></li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p><strong>argparse-cpp</strong> is free and open source. You can find the source code <a href="https://github.com/dead-tech/argparse-cpp">here</a>. Issues and feature requests can be posted on the <a href="https://github.com/dead-tech/argparse-cpp/issues">GitHub issue tracker</a>. If you'd like to contribute, consider opening a pull request.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The whole <strong>argparse-cpp</strong> project is released under <a href="https://github.com/dead-tech/argparse-cpp/LICENSE">MIT License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are different ways of installing the library. Choose whatever you think is the best for you.</p>
<ul>
<li><a href="user_guide/installation.html#installation">Installation</a>
<ul>
<li><a href="user_guide/installation.html#using-conan-package-manager">Using conan package manager</a></li>
<li><a href="user_guide/installation.html#download-source-code-from-latest-release">Download source code from latest release</a></li>
<li><a href="user_guide/installation.html#downloading-the-header-file">Downloading the header file</a></li>
<li><a href="user_guide/installation.html#cloning-the-repo">Cloning the repo</a></li>
</ul>
</li>
</ul>
<h2 id="using-conan-package-manager"><a class="header" href="#using-conan-package-manager">Using conan package manager</a></h2>
<p><em>Starting from release <strong>v0.1.0</strong> it is possible to use conan in order to install the library from the artifactory remote</em></p>
<p>For these steps to work you will need both <a href="https://docs.conan.io/en/latest/installation.html">conan</a> and <a href="https://cmake.org/install/">CMake</a>. Check their respective installation guides for further information on how to get those tools.</p>
<ol>
<li>
<p>Create a simple conanfile.txt in the root of your project containing the requirements</p>
<pre><code class="language-txt">[requires]
  argparse-cpp/0.1.0@dead/stable

[generators]
  cmake
</code></pre>
</li>
<li>
<p>Move into the build folder</p>
<pre><code class="language-bash">$ cd &lt;build-folder&gt;
</code></pre>
</li>
<li>
<p>Add the artifactory remote to your conan client</p>
<pre><code class="language-bash">$ conan remote add argparse-cpp https://argparsecpp.jfrog.io/artifactory/api/conan/argparse-cpp-conan-local
</code></pre>
</li>
<li>
<p>Run <code>conan install</code></p>
<pre><code class="language-bash">$ conan install .. -r argparse-cpp
</code></pre>
</li>
<li>
<p>Configure cmake to use the installed library from conan</p>
<pre><code class="language-cmake">include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)
conan_basic_setup(NO_OUTPUT_DIRS TARGETS)
...
target_link_libraries(your_exe PUBLIC CONAN_PKG::argparse-cpp)
</code></pre>
</li>
</ol>
<h2 id="download-source-code-from-latest-release"><a class="header" href="#download-source-code-from-latest-release">Download source code from latest release</a></h2>
<p>Click on the releases header on the right side of the GitHub repo or navigate <a href="https://github.com/dead-tech/argparse-cpp/releases">here</a></p>
<p>Scroll down to the assets section and download the source code (zip or tar.gz).</p>
<h2 id="downloading-the-header-file"><a class="header" href="#downloading-the-header-file">Downloading the header file</a></h2>
<p>Get the header file through wget.</p>
<pre><code class="language-bash">$ wget https://raw.githubusercontent.com/dead-tech/argparse-cpp/main/include/argparse/argparse.hpp
</code></pre>
<h2 id="cloning-the-repo"><a class="header" href="#cloning-the-repo">Cloning the repo</a></h2>
<ol>
<li>
<p>Clone the repo</p>
<pre><code class="language-bash">$ git clone https://github.com/dead-tech/argparse-cpp.git
</code></pre>
</li>
<li>
<p>Change current directory to the cloned folder</p>
<pre><code class="language-bash">$ cd argparse-cpp
</code></pre>
</li>
<li>
<p>Move the header file</p>
<pre><code class="language-bash">$ mv include/argparse.hpp &lt;your-project-include-path&gt;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-tests"><a class="header" href="#running-the-tests">Running the tests</a></h1>
<p>This project uses <a href="https://github.com/catchorg/Catch2">Catch2</a> testing framework.
You can find the whole test suite <a href="https://github.com/dead-tech/argparse-cpp/tree/main/tests">here</a>.</p>
<p>If you would like to, you can run the test suite yourself by following the instructions below.</p>
<ol>
<li>
<p>Clone the repository.</p>
<pre><code class="language-bash">$ git clone https://github.com/dead-tech/argparse-cpp
</code></pre>
</li>
<li>
<p>Change directory to the repository root.</p>
<pre><code class="language-bash">$ cd argparse-cpp
</code></pre>
</li>
<li>
<p>Create a build folder and cd into it.</p>
<pre><code class="language-bash">$ mkdir build &amp;&amp; cd build
</code></pre>
</li>
<li>
<p>Install the conan dependecies.</p>
<pre><code class="language-bash">$ conan install ..
</code></pre>
<p>If this does not work for you checkout the <a href="user_guide/installation.html">installation section</a> for further instructions.</p>
</li>
<li>
<p>Configure cmake and compile the tests</p>
<pre><code class="language-bash">$ cmake .. &amp;&amp; make
</code></pre>
<p>You can also specify a number of jobs as an argument to the <code>make</code> command to speed up the compilation process like so <code>make -j5</code>.</p>
</li>
<li>
<p>Run the tests</p>
<pre><code class="language-bash">$ ./argparse-cpp_tests
</code></pre>
</li>
</ol>
<br>
<p>Currently all the tests are expected to: <img src="https://github.com/dead-tech/argparse-cpp/actions/workflows/linux.yml/badge.svg" alt="Build Status" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h1>
<p>Simple example program that emulates an hypothetically compiler CLI.
You may use this to get a general idea of what it would like to crete an application using this library.</p>
<pre><code class="language-cpp">#include &lt;argparse/argparse.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main(int argc, const char **argv)
{
    argparse::ArgumentParser parser(argc, argv);

    parser.add_argument(&quot;files&quot;)
            .set_type(argparse::ArgTypes::STRING)
            .set_default(&quot;test.txt&quot;)
            .set_help(&quot;Paths to the files to compile&quot;)
            .set_flags(argparse::ArgFlags::REQUIRED)
            .set_metavar(&quot;FILE_PATH&quot;)
            .set_nargs('+');

    parser.add_argument(&quot;--release&quot;, &quot;-R&quot;)
            .set_type(argparse::ArgTypes::BOOL)
            .set_help(&quot;Build in release version&quot;);

    const auto args = parser.parse_args();

    const auto files = args.at(&quot;files&quot;).as&lt;std::vector&lt;std::string&gt;&gt;();
    const auto is_release = args.at(&quot;--release&quot;).as&lt;bool&gt;();

    const auto result = build_files(files, is_release);
}
</code></pre>
<p>After compiling the program can ben run at the command line as follows:</p>
<pre><code class="language-bash">$ ./program_name args...
</code></pre>
<p><strong>Note</strong>: You will get automatically generated <strong>help</strong> and <strong>version</strong> optional arguments that will respectively produce the following output</p>
<p>Version optional argument:</p>
<pre><code class="language-bash">$ ./main --version
0.0.1
</code></pre>
<p>Help optional argument:</p>
<pre><code class="language-bash">$ ./main --help
usage: ./main [-H] [--release --RELEASE] files FILE_PATH

required arguments:
  files FILE_PATH Paths to the files to compile

optional arguments:
  -H, --help            show this help message and exit
  --release, -R --RELEASE Build in release version
</code></pre>
<p>When run with the appropriate arguments it should print the following output:</p>
<pre><code class="language-bash">$ ./main files.txt bar.json --release
Built files:
files.txt bar.json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argumentparser-objects"><a class="header" href="#argumentparser-objects">ArgumentParser objects</a></h1>
<h3 id="function-signature"><a class="header" href="#function-signature">Function signature</a></h3>
<pre><code class="language-cpp">class ArgumentParser
{
public:
    ArgumentParser(const int argc, const char **argv, std::string version = &quot;0.0.1&quot;);
}
</code></pre>
<p>The constructor creates a new <code>ArgumentParser</code> object. All the parameters except for the version are required. Each of the parameters is described more in detail below.</p>
<ul>
<li><code>argc</code> - The number of arguments passed to the program</li>
<li><code>argv</code> - The array of arguments passed to the program</li>
<li><code>version</code> - The version of the program (optional - defaults to &quot;0.0.1&quot;)</li>
</ul>
<h3 id="detail"><a class="header" href="#detail">Detail</a></h3>
<p><strong>argc</strong>
<br>
This parameter is used to determine the number of arguments passed to the program. Not only in C++ there is no practical way of eliminating this parameter from the function signature, but this makes it also convenient to test the library.</p>
<p><strong>argv</strong>
<br>
This parameter represent the array of arguments passed to the program. As for <a href="in_depth/argument_parser_objects.html#argc">argc</a> not only in C++ there is no practical way of eliminating this parameter from the function signature, but this makes it also convenient to test the library or perhaps providing your own arguments for whatever reason.</p>
<p><strong>version</strong>
<br>
This parameter is used to provide a custom version of the program. If it is left blank it will default to &quot;0.0.1&quot;. Note that the library will automatically generate an optional argument, as a builtin, for displaying the version of the program on command.
The builtin can be invoked with the <code>--version</code> or <code>-V</code> argument as shown below.</p>
<pre><code class="language-bash">$ ./program_name --version
0.0.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-add_argument-method"><a class="header" href="#the-add_argument-method">The add_argument() method</a></h1>
<h3 id="function-signature-1"><a class="header" href="#function-signature-1">Function signature</a></h3>
<pre><code class="language-cpp">template&lt;utils::StringLike... Names&gt;
mapped_type &amp;add_argument(Names &amp;&amp;...names);
</code></pre>
<ul>
<li>
<p><code>utils::StringLike</code> - A C++20 concept that allows you to pass any type <code>T</code> which is convertible to a <code>std::string</code></p>
</li>
<li>
<p><code>Names &amp;&amp;...names</code> - A variadic pack of <code>utils::StringLike</code>s containing all the names for the argument, including the primary name and the optional aliases</p>
</li>
<li>
<p><code>mapped_type &amp;</code> - The return type of the method which is a reference to the argument object. By returning a non-<code>const</code> reference to the newly created argument object, you can modify the argument object by using the object chaining method, which our API is based on.
<em>mapped_type</em> is just an aliased type:</p>
<pre><code class="language-cpp">using map_type       = std::unordered_map&lt;std::string, Arg&gt;;
using mapped_type    = map_type::mapped_type;
</code></pre>
</li>
</ul>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<p><strong>Important:</strong> As shown by the <code>static_assert</code> below you must provide at least one argument as a name for the argument itself. If you're trying to register an optional argument one of the names <strong>must</strong> also start with a <code>--</code>. The latter name will be used as the primary name of the argument, for example to index and retrieve the argument in the internal storage. Whereas for positional arguments you should pass only one argument, the others will be discard and only the first one will be used.</p>
<pre><code class="language-cpp">static_assert(
    sizeof...(Names) &gt; 0,
    &quot;[argparse] error: add_argument() needs at least one argument as a name (starting with '--' for &quot;
    &quot;positional arguments)&quot;);
</code></pre>
<h3 id="runtime-dispatch-based-on-argument-kind"><a class="header" href="#runtime-dispatch-based-on-argument-kind">Runtime dispatch based on argument kind</a></h3>
<p>As we have briefly mentioned above the same method can be used to create both optional and positional arguments. The system will automatically make its way between the two and dispatch to the appropriate method.</p>
<pre><code class="language-cpp">if (arg_kind == ArgKind::Positional) {
    return this-&gt;add_positional_argument(data);
} else if (arg_kind == ArgKind::Optional) {
    return this-&gt;add_optional_argument(data, primary_name.value());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-parse_args-method"><a class="header" href="#the-parse_args-method">The parse_args() method</a></h1>
<h3 id="function-signature-2"><a class="header" href="#function-signature-2">Function signature</a></h3>
<pre><code class="language-cpp">[[nodiscard]] map_type parse_args();
</code></pre>
<h3 id="explanation-of-how-it-works"><a class="header" href="#explanation-of-how-it-works">Explanation of how it works</a></h3>
<ul>
<li><code>map_type</code> is equivalent to <code>std::unordered_map&lt;std::string, Arg&gt;</code></li>
<li>The function will immediately create the usage and help messages to be display on command
<pre><code class="language-cpp">this-&gt;create_usage_message();
this-&gt;create_help_message();
</code></pre>
</li>
<li>The function will also before even parsing the command line arguments check if any builtins are present and if so, execute them
<pre><code class="language-cpp">if (const auto builtin = this-&gt;get_builtin_if(); builtin.has_value()) {
    const auto fn = builtin.value();
    fn();
    exit(0);
}
</code></pre>
</li>
<li>The function will then split the program arguments into positional and optional arguments
<pre><code class="language-cpp">const auto [positional_args, optional_args] = this-&gt;split_program_args();
</code></pre>
</li>
<li>The function will then parse the positional arguments
<pre><code class="language-cpp">this-&gt;parse_positional_args(positional_args);
</code></pre>
</li>
<li>The function will then throw if a not registered optional argument is found in the program args
<pre><code class="language-cpp">this-&gt;throw_if_unrecognized(optional_args);
this-&gt;parse_optional_args(optional_args);
</code></pre>
</li>
</ul>
<p>Whatever is returned from the function can be then accessed through the .at() method and then cast to the appropriate type as it is explained <a href="in_depth/./arg_methods/as.html">here</a>.</p>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<p>Be also aware that this function may throw an exception in one of these cases:</p>
<ul>
<li>If not enough positional arguments were provided</li>
<li>If an optional argument that is not registered was provided</li>
</ul>
<p><strong>NOTE</strong>: The return type of the method is marked as <code>[[nodiscard]]</code> which means that the result of the call to this method cannot be ignored and the value has necessarily to be stored in a variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_type"><a class="header" href="#set_type">set_type()</a></h1>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<p>This method allows you to set the type of type of the argument that has to be parsed from the command line arguments.
<br></p>
<p>It is used to parse differently based on the type of the argument. For example, boolean arguments do not expect after their name any kind of value, whereas string or int arguments do.</p>
<h3 id="list-of-supported-argument-types"><a class="header" href="#list-of-supported-argument-types">List of supported argument types</a></h3>
<p>It is worth be aware of that if you do not call <code>set_type()</code>, on a <code>Arg</code> instance, the type of the argument will default to <code>argparse::ArgTypes::STRING</code>.</p>
<pre><code class="language-cpp">enum class ArgTypes
{
    STRING = 0,
    INT,
    BOOL
};
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--string&quot;, &quot;-S&quot;).set_type(argparse::ArgTypes::STRING);
parser.add_argument(&quot;--int&quot;, &quot;-I&quot;).set_type(argparse::ArgTypes::INT);
parser.add_argument(&quot;--bool&quot;, &quot;-B&quot;).set_type(argparse::ArgTypes::BOOL);
</code></pre>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;set_type(const ArgTypes &amp;type)
{
    this-&gt;type = type;
    return *this;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_flags"><a class="header" href="#set_flags">set_flags()</a></h1>
<h3 id="rationale-1"><a class="header" href="#rationale-1">Rationale</a></h3>
<p>This method allows you to set some flags for the argument that has to be parsed from the command line arguments.
<br></p>
<p>We currently use a bitmask to encode all the various flags to ease the usage.</p>
<h3 id="list-of-flags-you-may-specify"><a class="header" href="#list-of-flags-you-may-specify">List of flags you may specify</a></h3>
<p>It is worth be aware of that if you do not call <code>set_flags()</code>, on a <code>Arg</code> instance, the type of the argument will default to <code>argparse::ArgFlags::DEFAULT</code> which is only <code>STORE_TRUE</code> at the moment as shown below.</p>
<pre><code class="language-cpp">enum class ArgFlags : int64_t
{
    NONE        = 0,
    REQUIRED    = (1LL &lt;&lt; 1),
    STORE_TRUE  = (1LL &lt;&lt; 2),
    STORE_FALSE = (1LL &lt;&lt; 3),

    DEFAULT = STORE_TRUE,
};
</code></pre>
<h3 id="example-usage-1"><a class="header" href="#example-usage-1">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--release&quot;, &quot;-R&quot;)
    .set_flags(argparse::ArgFlags::REQUIRED | argparse::ArgFlags::STORE_TRUE);
</code></pre>
<h3 id="source-code-1"><a class="header" href="#source-code-1">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;set_flags(const ArgFlags &amp;flags)
{
    this-&gt;flags = flags;
    return *this;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_help"><a class="header" href="#set_help">set_help()</a></h1>
<h3 id="rationale-2"><a class="header" href="#rationale-2">Rationale</a></h3>
<p>This method allows you to set a custom help message that has to be printed next to the argument name when invoking the <code>--help</code> builtin.</p>
<h3 id="example-usage-2"><a class="header" href="#example-usage-2">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--release&quot;, &quot;-R&quot;).set_help(&quot;Set build process in release mode&quot;);
</code></pre>
<h3 id="source-code-2"><a class="header" href="#source-code-2">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;set_help(const std::string &amp;help_message)
{
    this-&gt;help_message = help_message;
    return *this;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_default"><a class="header" href="#set_default">set_default()</a></h1>
<h3 id="rationale-3"><a class="header" href="#rationale-3">Rationale</a></h3>
<p>This method allows you to set a default value for an argument. This value will be used if the user does not provide a value for the argument.</p>
<p><strong>NOTE</strong>: Be aware that if a required argument is not provived the default value will be used and no error will be thrown.</p>
<p><strong>IMPORTANT:</strong> Executing a builting command such as <code>--help</code> or <code>--version</code> will quit the program with zero exit code.</p>
<h3 id="example-usage-3"><a class="header" href="#example-usage-3">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--jobs&quot;, &quot;-J&quot;).set_default(1);
</code></pre>
<h3 id="source-code-3"><a class="header" href="#source-code-3">Source Code</a></h3>
<pre><code class="language-cpp">template&lt;SupportedArgumentType T&gt;
Arg &amp;set_default(T &amp;&amp;value)
{
    if constexpr (std::is_convertible_v&lt;T, std::string&gt;) {
        this-&gt;values.front() = std::forward&lt;T&gt;(value);
    } else if constexpr (std::is_same_v&lt;T, bool&gt;) {
        this-&gt;values.front() = utils::bool_to_str(std::forward&lt;T&gt;(value));
    } else {
        this-&gt;values.front() = std::to_string(std::forward&lt;T&gt;(value));
    }

    return *this;
}
</code></pre>
<p>This templated function is restricted in its types by the concept <code>SupportedArgumentTypes</code>. The latter allows you to pass as an argument to the call just the types that are supported by the library (see <a href="in_depth/arg_methods/set_type.html">set_type()</a> for more info).
<br>
Moreover the function uses C++17 <code>if constexpr</code> to generate at compile time the right branch of the <code>if</code> statement, reducing the overhead during runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_metavar"><a class="header" href="#set_metavar">set_metavar()</a></h1>
<h3 id="rationale-4"><a class="header" href="#rationale-4">Rationale</a></h3>
<p>This method allows you to specify a custom metavar. A metavar is the string it is printed next to the argument name when invoking the <code>--help</code> builtin that helps you understand where you have to specify the value of the argument.</p>
<p>Example: <code>program_name --out output_file</code></p>
<p>In the example above <i>output_file</i> is the metavar.</p>
<h3 id="example-usage-4"><a class="header" href="#example-usage-4">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--out&quot;, &quot;-O&quot;).set_metavar(&quot;output_file&quot;);
</code></pre>
<h3 id="source-code-4"><a class="header" href="#source-code-4">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;set_metavar(const std::string &amp;metavar)
{
    this-&gt;metavar = metavar;
    return *this;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_nargs"><a class="header" href="#set_nargs">set_nargs()</a></h1>
<h3 id="rationale-5"><a class="header" href="#rationale-5">Rationale</a></h3>
<p>This method allows you to set how many values are expected for an argument.</p>
<h3 id="possible-values"><a class="header" href="#possible-values">Possible values</a></h3>
<p>You may specify as an argument to this function one of the following values:</p>
<ul>
<li>x -&gt; any integer number</li>
<li>* -&gt; which means at zero or more values</li>
<li>+ -&gt; which means at least one or more values</li>
</ul>
<h3 id="example-usage-5"><a class="header" href="#example-usage-5">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;files&quot;).set_nargs('*');
</code></pre>
<h3 id="source-code-5"><a class="header" href="#source-code-5">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;set_nargs(const auto nargs)
{
    static constexpr auto is_number = std::is_same_v&lt;decltype(nargs), const int&gt;;
    static constexpr auto is_symbol = std::is_same_v&lt;decltype(nargs), const char&gt;;

    if constexpr (is_number) {
        this-&gt;nargs = nargs;
    } else if constexpr (is_symbol) {
        this-&gt;nargs = nargs - '0';
    } else {
        throw exceptions::ArgparseException(
            std::source_location::current(),
            &quot;set_nargs() error: unsupported type: %\nSupported types are: int, std::string\n&quot;,
            typeid(nargs).name());
    }

    return *this;
}
</code></pre>
<p>Moreover the function uses C++17 <code>if constexpr</code> to generate at compile time the right branch of the <code>if</code> statement, reducing the overhead during runtime.
<br></p>
<p><strong>Note:</strong> Be aware that the function will throw an exception if the argument is not a number or one of the supported symbols symbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count"><a class="header" href="#count">count()</a></h1>
<h3 id="rationale-6"><a class="header" href="#rationale-6">Rationale</a></h3>
<p>This method allows you to count the occurence of an argument in the command line arguments.</p>
<h3 id="example-usage-6"><a class="header" href="#example-usage-6">Example usage</a></h3>
<pre><code class="language-cpp">parser.add_argument(&quot;--verbose&quot;).count();
</code></pre>
<h3 id="source-code-6"><a class="header" href="#source-code-6">Source Code</a></h3>
<pre><code class="language-cpp">Arg &amp;count()
{
    this-&gt;count_occurence = true;
    this-&gt;type            = ArgTypes::BOOL;
    return *this;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as"><a class="header" href="#as">as()</a></h1>
<h3 id="rationale-7"><a class="header" href="#rationale-7">Rationale</a></h3>
<p>This method allows you to cast the <code>Arg</code> value (a.k.a. <code>std::string</code>) you get when invoking the <code>at()</code> method on the return value of the <code>parse_args()</code> method (<a href="in_depth/arg_methods/../parse_args.html">more info</a>) to the type of your needs.</p>
<h3 id="list-of-supported-types"><a class="header" href="#list-of-supported-types">List of supported types</a></h3>
<ul>
<li><code>int</code> - <code>std::is_integral_v&lt;T&gt;</code> - actually every integral type</li>
<li><code>std::vector&lt;int&gt;</code></li>
<li><code>std::string</code></li>
<li><code>std::vector&lt;std::string&gt;</code></li>
<li><code>bool</code></li>
</ul>
<h3 id="example-usage-7"><a class="header" href="#example-usage-7">Example usage</a></h3>
<pre><code class="language-cpp">const auto args = parser.parse_args();
const auto value = args.at('--value').as&lt;int&gt;();
</code></pre>
<h3 id="source-code-7"><a class="header" href="#source-code-7">Source Code</a></h3>
<pre><code class="language-cpp">template&lt;typename ReturnType&gt;
[[nodiscard]] decltype(auto) as() const
{
    static constexpr auto is_int        = std::is_integral_v&lt;ReturnType&gt; &amp;&amp; !std::is_same_v&lt;ReturnType, bool&gt;;
    static constexpr auto is_vec_int    = std::is_same_v&lt;ReturnType, std::vector&lt;int&gt;&gt;;
    static constexpr auto is_string     = std::is_same_v&lt;ReturnType, std::string&gt;;
    static constexpr auto is_vec_string = std::is_same_v&lt;ReturnType, std::vector&lt;std::string&gt;&gt;;
    static constexpr auto is_bool       = std::is_same_v&lt;ReturnType, bool&gt;;

    if constexpr (is_int) {
        return utils::impl::str_to_int_helper(this-&gt;values.front());
    } else if constexpr (is_vec_int) {
        return utils::str_to_int(this-&gt;values);
    } else if constexpr (is_string) {
        return values.front();
    } else if constexpr (is_vec_string) {
        return std::vector(values.data(), values.data() + this-&gt;actual_size);
    } else if constexpr (is_bool) {
        return utils::str_to_bool(this-&gt;values.front());
    }

    throw exceptions::ArgparseException(
        std::source_location::current(),
        &quot;as&lt;%&gt;() error: unsupported return type\nSupported types are: int, std::vector&lt;int&gt;, std::string, &quot;
        &quot;std::vector&lt;std::string&gt;, bool\n&quot;,
        typeid(ReturnType).name());
}
</code></pre>
<p>The function uses C++17 <code>if constexpr</code> to generate at compile time the right branch of the <code>if</code> statement, reducing the overhead during runtime.</p>
<p><strong>NOTE</strong>: If the type passed as a template argument to this method is not one of the supported types, the function will throw an exception.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
